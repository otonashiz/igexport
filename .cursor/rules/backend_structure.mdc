---
description:
globs:
alwaysApply: false
---
# IGExportGuru - åç«¯æ¶æ„æ–‡æ¡£

## ğŸ“ é¡¹ç›®ç»“æ„

### ç›®å½•ç»„ç»‡
```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/          # æ§åˆ¶å™¨å±‚
â”‚   â”‚   â”œâ”€â”€ exportController.ts
â”‚   â”‚   â”œâ”€â”€ healthController.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ services/            # æœåŠ¡å±‚
â”‚   â”‚   â”œâ”€â”€ instagramService.ts
â”‚   â”‚   â”œâ”€â”€ exportService.ts
â”‚   â”‚   â”œâ”€â”€ validationService.ts
â”‚   â”‚   â””â”€â”€ fileService.ts
â”‚   â”œâ”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ scraper.ts
â”‚   â”‚   â”œâ”€â”€ validator.ts
â”‚   â”‚   â”œâ”€â”€ formatter.ts
â”‚   â”‚   â”œâ”€â”€ constants.ts
â”‚   â”‚   â””â”€â”€ logger.ts
â”‚   â”œâ”€â”€ types/               # TypeScriptç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ instagram.ts
â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â””â”€â”€ common.ts
â”‚   â”œâ”€â”€ middleware/          # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ validation.ts
â”‚   â”‚   â”œâ”€â”€ rateLimit.ts
â”‚   â”‚   â””â”€â”€ errorHandler.ts
â”‚   â”œâ”€â”€ config/              # é…ç½®æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ database.ts
â”‚   â”‚   â”œâ”€â”€ cache.ts
â”‚   â”‚   â””â”€â”€ environment.ts
â”‚   â””â”€â”€ app.ts               # Expressåº”ç”¨é…ç½®
â”œâ”€â”€ tests/                   # æµ‹è¯•æ–‡ä»¶
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ __mocks__/
â”œâ”€â”€ dist/                    # ç¼–è¯‘è¾“å‡º
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ .env.example
â””â”€â”€ README.md
```

## ğŸ¯ APIè®¾è®¡è§„èŒƒ

### RESTful APIç»“æ„
```typescript
// APIè·¯ç”±è®¾è®¡
GET    /api/health              # å¥åº·æ£€æŸ¥
POST   /api/export/analyze      # åˆ†æInstagramè´¦æˆ·
POST   /api/export/followers    # å¯¼å‡ºå…³æ³¨è€…
POST   /api/export/following    # å¯¼å‡ºå…³æ³¨åˆ—è¡¨
GET    /api/export/status/:id   # æŸ¥è¯¢å¯¼å‡ºçŠ¶æ€
GET    /api/export/download/:id # ä¸‹è½½å¯¼å‡ºæ–‡ä»¶
```

### æ§åˆ¶å™¨å®ç°
```typescript
// src/controllers/exportController.ts
import { Request, Response } from 'express';
import { InstagramService } from '../services/instagramService';
import { ExportService } from '../services/exportService';
import { ValidationService } from '../services/validationService';
import { ApiResponse, ExportRequest, ExportResult } from '../types/api';

export class ExportController {
  private instagramService: InstagramService;
  private exportService: ExportService;
  private validationService: ValidationService;

  constructor() {
    this.instagramService = new InstagramService();
    this.exportService = new ExportService();
    this.validationService = new ValidationService();
  }

  // åˆ†æInstagramè´¦æˆ·
  public analyzeAccount = async (req: Request, res: Response): Promise<void> => {
    try {
      const { username } = req.body;
      
      // éªŒè¯è¾“å…¥
      const validationResult = this.validationService.validateUsername(username);
      if (!validationResult.isValid) {
        res.status(400).json({
          success: false,
          error: validationResult.error,
        } as ApiResponse<null>);
        return;
      }

      // è·å–è´¦æˆ·ä¿¡æ¯
      const accountInfo = await this.instagramService.getAccountInfo(username);
      
      res.json({
        success: true,
        data: accountInfo,
      } as ApiResponse<typeof accountInfo>);
    } catch (error) {
      this.handleError(res, error);
    }
  };

  // å¯¼å‡ºå…³æ³¨è€…
  public exportFollowers = async (req: Request, res: Response): Promise<void> => {
    try {
      const exportRequest: ExportRequest = req.body;
      
      // éªŒè¯è¯·æ±‚
      const validationResult = this.validationService.validateExportRequest(exportRequest);
      if (!validationResult.isValid) {
        res.status(400).json({
          success: false,
          error: validationResult.error,
        } as ApiResponse<null>);
        return;
      }

      // åˆ›å»ºå¯¼å‡ºä»»åŠ¡
      const taskId = await this.exportService.createExportTask(exportRequest);
      
      // å¼‚æ­¥æ‰§è¡Œå¯¼å‡º
      this.executeExport(taskId, exportRequest);
      
      res.json({
        success: true,
        data: { taskId, status: 'processing' },
      } as ApiResponse<{ taskId: string; status: string }>);
    } catch (error) {
      this.handleError(res, error);
    }
  };

  // æŸ¥è¯¢å¯¼å‡ºçŠ¶æ€
  public getExportStatus = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const status = await this.exportService.getTaskStatus(id);
      
      res.json({
        success: true,
        data: status,
      } as ApiResponse<typeof status>);
    } catch (error) {
      this.handleError(res, error);
    }
  };

  // ä¸‹è½½å¯¼å‡ºæ–‡ä»¶
  public downloadExport = async (req: Request, res: Response): Promise<void> => {
    try {
      const { id } = req.params;
      const filePath = await this.exportService.getExportFile(id);
      
      res.download(filePath, (err) => {
        if (err) {
          this.handleError(res, err);
        }
      });
    } catch (error) {
      this.handleError(res, error);
    }
  };

  private executeExport = async (taskId: string, request: ExportRequest): Promise<void> => {
    try {
      await this.exportService.updateTaskStatus(taskId, 'processing');
      
      // è·å–Instagramæ•°æ®
      const data = await this.instagramService.getFollowers(
        request.username,
        request.maxCount || 200
      );
      
      // ç”ŸæˆExcelæ–‡ä»¶
      const filePath = await this.exportService.generateExcelFile(taskId, data);
      
      await this.exportService.updateTaskStatus(taskId, 'completed', { filePath });
    } catch (error) {
      await this.exportService.updateTaskStatus(taskId, 'failed', { error: error.message });
    }
  };

  private handleError = (res: Response, error: any): void => {
    console.error('Export Controller Error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error',
    } as ApiResponse<null>);
  };
}
```

## ğŸ”§ æœåŠ¡å±‚è®¾è®¡

### Instagramæ•°æ®æœåŠ¡
```typescript
// src/services/instagramService.ts
import puppeteer, { Browser, Page } from 'puppeteer';
import { InstagramUser, AccountInfo } from '../types/instagram';
import { Logger } from '../utils/logger';

export class InstagramService {
  private browser: Browser | null = null;
  private logger: Logger;

  constructor() {
    this.logger = new Logger('InstagramService');
  }

  // åˆå§‹åŒ–æµè§ˆå™¨
  private async initBrowser(): Promise<Browser> {
    if (!this.browser) {
      this.browser = await puppeteer.launch({
        headless: true,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--no-first-run',
          '--no-zygote',
          '--single-process',
          '--disable-gpu',
        ],
      });
    }
    return this.browser;
  }

  // è·å–è´¦æˆ·åŸºæœ¬ä¿¡æ¯
  public async getAccountInfo(username: string): Promise<AccountInfo> {
    const browser = await this.initBrowser();
    const page = await browser.newPage();

    try {
      // è®¾ç½®ç”¨æˆ·ä»£ç†
      await page.setUserAgent(
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      );

      // è®¿é—®Instagramä¸ªäººèµ„æ–™é¡µé¢
      const url = `https://www.instagram.com/${username}/`;
      await page.goto(url, { waitUntil: 'networkidle2' });

      // ç­‰å¾…é¡µé¢åŠ è½½
      await page.waitForSelector('article', { timeout: 10000 });

      // æå–è´¦æˆ·ä¿¡æ¯
      const accountInfo = await page.evaluate(() => {
        const getTextContent = (selector: string): string => {
          const element = document.querySelector(selector);
          return element?.textContent?.trim() || '';
        };

        const getFollowerCount = (): number => {
          const followerElement = document.querySelector('a[href$="/followers/"] span');
          const text = followerElement?.textContent?.trim() || '0';
          return parseInt(text.replace(/[,\s]/g, '')) || 0;
        };

        const getFollowingCount = (): number => {
          const followingElement = document.querySelector('a[href$="/following/"] span');
          const text = followingElement?.textContent?.trim() || '0';
          return parseInt(text.replace(/[,\s]/g, '')) || 0;
        };

        return {
          userName: window.location.pathname.split('/')[1],
          fullName: getTextContent('h2'),
          isVerified: !!document.querySelector('[data-testid="verifiedBadge"]'),
          followerCount: getFollowerCount(),
          followingCount: getFollowingCount(),
          isPrivate: !!document.querySelector('[data-testid="private_account"]'),
        };
      });

      return {
        ...accountInfo,
        profileUrl: url,
      };
    } catch (error) {
      this.logger.error('Failed to get account info', error);
      throw new Error('Failed to fetch Instagram account information');
    } finally {
      await page.close();
    }
  }

  // è·å–å…³æ³¨è€…åˆ—è¡¨
  public async getFollowers(username: string, maxCount: number = 200): Promise<InstagramUser[]> {
    const browser = await this.initBrowser();
    const page = await browser.newPage();

    try {
      await page.setUserAgent(
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      );

      // è®¿é—®å…³æ³¨è€…é¡µé¢
      const url = `https://www.instagram.com/${username}/followers/`;
      await page.goto(url, { waitUntil: 'networkidle2' });

      // æ£€æŸ¥æ˜¯å¦ä¸ºç§äººè´¦æˆ·
      const isPrivate = await page.$('[data-testid="private_account"]');
      if (isPrivate) {
        throw new Error('This account is private');
      }

      // ç­‰å¾…å…³æ³¨è€…åˆ—è¡¨åŠ è½½
      await page.waitForSelector('[role="dialog"]', { timeout: 10000 });

      // æ»šåŠ¨åŠ è½½æ›´å¤šå…³æ³¨è€…
      const followers: InstagramUser[] = [];
      let previousCount = 0;
      let retryCount = 0;

      while (followers.length < maxCount && retryCount < 10) {
        // æå–å½“å‰é¡µé¢çš„å…³æ³¨è€…
        const newFollowers = await page.evaluate(() => {
          const followerElements = document.querySelectorAll('[role="dialog"] [role="button"]');
          const users: any[] = [];

          followerElements.forEach((element) => {
            const usernameElement = element.querySelector('a[role="link"]');
            const fullNameElement = element.querySelector('span[dir="auto"]');
            const verifiedElement = element.querySelector('[data-testid="verifiedBadge"]');

            if (usernameElement) {
              const username = usernameElement.getAttribute('href')?.split('/')[1] || '';
              users.push({
                id: username,
                userName: username,
                fullName: fullNameElement?.textContent?.trim() || '',
                profileUrl: `https://www.instagram.com/${username}/`,
                isVerified: !!verifiedElement,
              });
            }
          });

          return users;
        });

        // æ·»åŠ æ–°çš„å…³æ³¨è€…ï¼ˆå»é‡ï¼‰
        newFollowers.forEach((follower) => {
          if (!followers.find((f) => f.userName === follower.userName)) {
            followers.push(follower);
          }
        });

        // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„å…³æ³¨è€…åŠ è½½
        if (followers.length === previousCount) {
          retryCount++;
        } else {
          retryCount = 0;
          previousCount = followers.length;
        }

        // æ»šåŠ¨åˆ°åº•éƒ¨åŠ è½½æ›´å¤š
        await page.evaluate(() => {
          const dialog = document.querySelector('[role="dialog"]');
          if (dialog) {
            dialog.scrollTop = dialog.scrollHeight;
          }
        });

        // ç­‰å¾…æ–°å†…å®¹åŠ è½½
        await page.waitForTimeout(2000);
      }

      return followers.slice(0, maxCount);
    } catch (error) {
      this.logger.error('Failed to get followers', error);
      throw new Error('Failed to fetch followers list');
    } finally {
      await page.close();
    }
  }

  // æ¸…ç†èµ„æº
  public async cleanup(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }
}
```

### å¯¼å‡ºæœåŠ¡
```typescript
// src/services/exportService.ts
import * as XLSX from 'xlsx';
import * as path from 'path';
import * as fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';
import { InstagramUser } from '../types/instagram';
import { ExportTask, ExportStatus } from '../types/export';

export class ExportService {
  private tasks: Map<string, ExportTask> = new Map();
  private exportDir: string;

  constructor() {
    this.exportDir = path.join(process.cwd(), 'exports');
    this.ensureExportDirectory();
  }

  // ç¡®ä¿å¯¼å‡ºç›®å½•å­˜åœ¨
  private async ensureExportDirectory(): Promise<void> {
    try {
      await fs.access(this.exportDir);
    } catch {
      await fs.mkdir(this.exportDir, { recursive: true });
    }
  }

  // åˆ›å»ºå¯¼å‡ºä»»åŠ¡
  public async createExportTask(request: any): Promise<string> {
    const taskId = uuidv4();
    const task: ExportTask = {
      id: taskId,
      status: 'pending',
      createdAt: new Date(),
      request,
    };

    this.tasks.set(taskId, task);
    return taskId;
  }

  // æ›´æ–°ä»»åŠ¡çŠ¶æ€
  public async updateTaskStatus(
    taskId: string,
    status: ExportStatus,
    data?: any
  ): Promise<void> {
    const task = this.tasks.get(taskId);
    if (task) {
      task.status = status;
      task.updatedAt = new Date();
      if (data) {
        task.result = data;
      }
      this.tasks.set(taskId, task);
    }
  }

  // è·å–ä»»åŠ¡çŠ¶æ€
  public async getTaskStatus(taskId: string): Promise<ExportTask | null> {
    return this.tasks.get(taskId) || null;
  }

  // ç”ŸæˆExcelæ–‡ä»¶
  public async generateExcelFile(
    taskId: string,
    data: InstagramUser[]
  ): Promise<string> {
    try {
      // å‡†å¤‡Excelæ•°æ®
      const worksheetData = [
        ['ID', 'Username', 'Full Name', 'Profile URL', 'Verified'], // è¡¨å¤´
        ...data.map((user) => [
          user.id,
          user.userName,
          user.fullName,
          user.profileUrl,
          user.isVerified ? 'Yes' : 'No',
        ]),
      ];

      // åˆ›å»ºå·¥ä½œç°¿å’Œå·¥ä½œè¡¨
      const workbook = XLSX.utils.book_new();
      const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);

      // è®¾ç½®åˆ—å®½
      worksheet['!cols'] = [
        { width: 15 }, // ID
        { width: 20 }, // Username
        { width: 25 }, // Full Name
        { width: 40 }, // Profile URL
        { width: 10 }, // Verified
      ];

      // è®¾ç½®è¡¨å¤´æ ·å¼
      const headerStyle = {
        font: { bold: true },
        fill: { fgColor: { rgb: 'E4405F' } },
        alignment: { horizontal: 'center' },
      };

      // åº”ç”¨è¡¨å¤´æ ·å¼
      for (let col = 0; col < 5; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: 0, c: col });
        if (!worksheet[cellAddress]) worksheet[cellAddress] = {};
        worksheet[cellAddress].s = headerStyle;
      }

      // æ·»åŠ å·¥ä½œè¡¨åˆ°å·¥ä½œç°¿
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Instagram Data');

      // ç”Ÿæˆæ–‡ä»¶åå’Œè·¯å¾„
      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `instagram_export_${taskId}_${timestamp}.xlsx`;
      const filePath = path.join(this.exportDir, filename);

      // å†™å…¥æ–‡ä»¶
      XLSX.writeFile(workbook, filePath);

      return filePath;
    } catch (error) {
      throw new Error(`Failed to generate Excel file: ${error.message}`);
    }
  }

  // è·å–å¯¼å‡ºæ–‡ä»¶
  public async getExportFile(taskId: string): Promise<string> {
    const task = this.tasks.get(taskId);
    if (!task || !task.result?.filePath) {
      throw new Error('Export file not found');
    }

    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    try {
      await fs.access(task.result.filePath);
      return task.result.filePath;
    } catch {
      throw new Error('Export file has been deleted');
    }
  }

  // æ¸…ç†è¿‡æœŸä»»åŠ¡
  public async cleanupExpiredTasks(): Promise<void> {
    const now = new Date();
    const expiredTasks: string[] = [];

    this.tasks.forEach((task, taskId) => {
      const ageInHours = (now.getTime() - task.createdAt.getTime()) / (1000 * 60 * 60);
      if (ageInHours > 24) { // 24å°æ—¶åæ¸…ç†
        expiredTasks.push(taskId);
      }
    });

    // åˆ é™¤è¿‡æœŸä»»åŠ¡å’Œæ–‡ä»¶
    for (const taskId of expiredTasks) {
      const task = this.tasks.get(taskId);
      if (task?.result?.filePath) {
        try {
          await fs.unlink(task.result.filePath);
        } catch {
          // æ–‡ä»¶å·²è¢«åˆ é™¤ï¼Œå¿½ç•¥é”™è¯¯
        }
      }
      this.tasks.delete(taskId);
    }
  }
}
```

## ğŸ›¡ï¸ å®‰å…¨ç­–ç•¥

### è¾“å…¥éªŒè¯
```typescript
// src/services/validationService.ts
export class ValidationService {
  // éªŒè¯Instagramç”¨æˆ·å
  public validateUsername(username: string): ValidationResult {
    if (!username || typeof username !== 'string') {
      return { isValid: false, error: 'Username is required' };
    }

    // æ¸…ç†ç”¨æˆ·å
    const cleanUsername = username
      .replace(/^https?:\/\/(www\.)?instagram\.com\//, '')
      .replace(/\/$/, '')
      .trim();

    // éªŒè¯ç”¨æˆ·åæ ¼å¼
    const usernameRegex = /^[a-zA-Z0-9._]{1,30}$/;
    if (!usernameRegex.test(cleanUsername)) {
      return {
        isValid: false,
        error: 'Invalid username format. Only letters, numbers, dots and underscores are allowed.',
      };
    }

    return { isValid: true, cleanValue: cleanUsername };
  }

  // éªŒè¯å¯¼å‡ºè¯·æ±‚
  public validateExportRequest(request: any): ValidationResult {
    const usernameValidation = this.validateUsername(request.username);
    if (!usernameValidation.isValid) {
      return usernameValidation;
    }

    const maxCount = parseInt(request.maxCount) || 200;
    if (maxCount < 1 || maxCount > 200) {
      return {
        isValid: false,
        error: 'Max count must be between 1 and 200',
      };
    }

    return { isValid: true };
  }
}
```

### è¯·æ±‚é™åˆ¶ä¸­é—´ä»¶
```typescript
// src/middleware/rateLimit.ts
import rateLimit from 'express-rate-limit';

// é€šç”¨é™åˆ¶
export const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
  max: 100, // é™åˆ¶æ¯ä¸ªIP 15åˆ†é’Ÿå†…æœ€å¤š100ä¸ªè¯·æ±‚
  message: {
    success: false,
    error: 'Too many requests, please try again later.',
  },
});

// å¯¼å‡ºAPIé™åˆ¶
export const exportLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1å°æ—¶
  max: 5, // é™åˆ¶æ¯ä¸ªIP 1å°æ—¶å†…æœ€å¤š5æ¬¡å¯¼å‡º
  message: {
    success: false,
    error: 'Export limit exceeded. Please try again in an hour.',
  },
});

// åˆ†æAPIé™åˆ¶
export const analyzeLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5åˆ†é’Ÿ
  max: 10, // é™åˆ¶æ¯ä¸ªIP 5åˆ†é’Ÿå†…æœ€å¤š10æ¬¡åˆ†æ
  message: {
    success: false,
    error: 'Analysis limit exceeded. Please try again in 5 minutes.',
  },
});
```

### é”™è¯¯å¤„ç†ä¸­é—´ä»¶
```typescript
// src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import { Logger } from '../utils/logger';

const logger = new Logger('ErrorHandler');

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  logger.error('API Error:', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
  });

  // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ä¸åŒçš„å“åº”
  if (error.name === 'ValidationError') {
    res.status(400).json({
      success: false,
      error: error.message,
    });
  } else if (error.name === 'RateLimitError') {
    res.status(429).json({
      success: false,
      error: 'Too many requests',
    });
  } else {
    res.status(500).json({
      success: false,
      error: 'Internal server error',
    });
  }
};
```

## ğŸ“Š ç›‘æ§å’Œæ—¥å¿—

### æ—¥å¿—ç³»ç»Ÿ
```typescript
// src/utils/logger.ts
export class Logger {
  private context: string;

  constructor(context: string) {
    this.context = context;
  }

  private formatMessage(level: string, message: string, data?: any): string {
    const timestamp = new Date().toISOString();
    const logData = data ? ` | Data: ${JSON.stringify(data)}` : '';
    return `[${timestamp}] [${level}] [${this.context}] ${message}${logData}`;
  }

  public info(message: string, data?: any): void {
    console.log(this.formatMessage('INFO', message, data));
  }

  public error(message: string, error?: any): void {
    console.error(this.formatMessage('ERROR', message, error));
  }

  public warn(message: string, data?: any): void {
    console.warn(this.formatMessage('WARN', message, data));
  }

  public debug(message: string, data?: any): void {
    if (process.env.NODE_ENV === 'development') {
      console.debug(this.formatMessage('DEBUG', message, data));
    }
  }
}
```

## ğŸš€ éƒ¨ç½²é…ç½®

### Dockeré…ç½®
```dockerfile
# Dockerfile
FROM node:18-alpine

# å®‰è£…Puppeteerä¾èµ–
RUN apk add --no-cache \
    chromium \
    nss \
    freetype \
    freetype-dev \
    harfbuzz \
    ca-certificates \
    ttf-freefont

# è®¾ç½®Puppeteerä½¿ç”¨ç³»ç»ŸChromium
ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true \
    PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium-browser

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 3001

CMD ["npm", "start"]
```

### ç¯å¢ƒå˜é‡
```bash
# .env.example
NODE_ENV=production
PORT=3001
API_BASE_URL=http://localhost:3001

# å®‰å…¨é…ç½®
CORS_ORIGIN=http://localhost:3000
RATE_LIMIT_ENABLED=true

# Puppeteeré…ç½®
PUPPETEER_ARGS=--no-sandbox,--disable-setuid-sandbox,--disable-dev-shm-usage

# æ—¥å¿—é…ç½®
LOG_LEVEL=info
LOG_FILE=logs/app.log

# æ–‡ä»¶å­˜å‚¨
EXPORT_DIR=./exports
MAX_FILE_AGE_HOURS=24
```

---

*æœ€åæ›´æ–°: 2024å¹´12æœˆ*
*ç‰ˆæœ¬: v1.0*
